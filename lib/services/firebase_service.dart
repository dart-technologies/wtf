import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/block.dart';
import '../models/person.dart';
import '../models/trip.dart';

/// Thin wrapper around Firestore for trip operations.
///
/// TODO(mike): implement each method body.
class FirebaseService {
  final FirebaseFirestore _db = FirebaseFirestore.instance;

  DocumentReference _tripRef(String tripId) =>
      _db.collection('trips').doc(tripId);

  // ---------------------------------------------------------------------------
  // Read
  // ---------------------------------------------------------------------------

  /// Stream of Trip updates. Both clients subscribe to this.
  Stream<Trip?> watchTrip(String tripId) {
    return _tripRef(tripId).snapshots().map((snap) {
      if (!snap.exists) return null;
      return Trip.fromMap(tripId, snap.data()! as Map<String, dynamic>);
    });
  }

  // ---------------------------------------------------------------------------
  // Write
  // ---------------------------------------------------------------------------

  /// Creates a new trip document with default blocks and two people.
  Future<void> createTrip({
    required String tripId,
    required String destination,
    required String personAName,
    required String personBName,
  }) async {
    final trip = Trip(
      tripId: tripId,
      destination: destination,
      people: {
        'person_a': Person(id: 'person_a', name: personAName),
        'person_b': Person(id: 'person_b', name: personBName),
      },
      blocks: {
        for (final b in defaultBlocks) b.id: b,
      },
    );
    await _tripRef(tripId).set(trip.toMap());
  }

  /// Claims a block for a person (or 'ai').
  Future<void> claimBlock({
    required String tripId,
    required String blockId,
    required String personId,
  }) async {
    await _tripRef(tripId).update({
      'blocks.$blockId.owner': personId,
      'blocks.$blockId.status': 'claimed',
    });
  }

  /// Records a decision step for a block.
  Future<void> addDecision({
    required String tripId,
    required String blockId,
    required Map<String, dynamic> decision,
  }) async {
    await _tripRef(tripId).update({
      'blocks.$blockId.decisions': FieldValue.arrayUnion([decision]),
      'blocks.$blockId.status': 'in_progress',
    });
  }

  /// Marks a block as decided with its final result.
  Future<void> resolveBlock({
    required String tripId,
    required String blockId,
    required Map<String, dynamic> result,
  }) async {
    await _tripRef(tripId).update({
      'blocks.$blockId.result': result,
      'blocks.$blockId.status': 'decided',
    });
  }

  /// Adds a conflict to the trip.
  Future<void> addConflict({
    required String tripId,
    required Map<String, dynamic> conflict,
  }) async {
    await _tripRef(tripId).update({
      'conflicts': FieldValue.arrayUnion([conflict]),
    });
  }

  /// Resolves a conflict and removes it from the list.
  Future<void> resolveConflict({
    required String tripId,
    required Map<String, dynamic> conflict,
  }) async {
    await _tripRef(tripId).update({
      'conflicts': FieldValue.arrayRemove([conflict]),
    });
  }

  /// Writes the final plan generated by Claude.
  Future<void> writeFinalPlan({
    required String tripId,
    required Map<String, dynamic> finalPlan,
  }) async {
    await _tripRef(tripId).update({'final_plan': finalPlan});
  }
}
